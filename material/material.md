# Course Material

- People
  - Why we build software: serving real people
  - Working with other humans (including future you)
  - Communication, feedback, collaboration
  - Agile, Lean, and other people-aware methods
  - Empathy in code, docs, and interface design
- Data
  - Definition
  - Collection
  - Use
  - Security
  - Storage
  - Ethics
  - Databases
    - Early databases
      - Ancient Sumer
      - Linked list
    - SQL
    - NoSQL
    - Other
      - Key-Value store
      - Graph
      - Vector
      - Timeseries
- Programming Practice
  - AI-assisted development tools
    - Agentic
  - IDEs and development tools
    - VSCode
    - VIM
  - Languages
    - Type Safety
  - Paradigms
    - Imperative/Procedural
    - Object Orientation (OO)
    - Functional Programming (FP)
    - Others: Logic, Array, AI
  - Testing
    - Types
      - Unit
      - Integration
      - End-to-End (E2E)
      - Acceptance
      - Regression
      - Performance (also known as Stress/Load)
      - Smoke
  - Package managers
  - Working with the command line
  - Version control (Git and GitHub)
  - Milestones
- Full-stack architecture
  - Frontend
    - Browsers
      - Document Object Model (DOM)
      - Event Loop
      - Separation of concerns
        - HyperText Markup Language (HTML)
          - content
        - Cascading Style Sheets (CSS)
          - presentation
        - JavaScript
          - interactivity
    - Frameworks
      *Frontend frameworks* are semantic abstractions that render user interfaces into the core technologies browsers understand: HTML, CSS, and JavaScript. The abstraction is *semantic* because the code expresses meaning (a button, a list, a stateful component) rather than mechanical instructions for DOM mutation. Instead of imperative code like `document.createElement("button")`, you write a component `<Button>Click me</Button>` or `button { label: "Click me" }`.
      - Component frameworks (e.g., React, Svelte)
        - React
          - Provides a virtual DOM representation of the UI.
          - Component functions return virtual nodes (JS objects).
          - On state changes, React diffs the new virtual tree against the old and applies the minimal set of DOM mutations.
          - JSX compiles to React.createElement calls, which build the virtual DOM objects.
        - Svelte
          - No virtual DOM.
          - Compiler runs at build-time: your components are converted into minimal imperative JavaScript that directly manipulates the DOM.
          - Reactive statements ($:) are compiled into update functions.
          - Runtime overhead is very small since most work happens during compilation.
    - User experience design (UXD)
      - Accessibility and usability (a11y)
      - Internationalization (i18n)
    - Styling and layout systems (CSS, Tailwind, etc.)
    - Frontend build tools and bundlers
    - State management
  - Backend
    - What is a server?
      - Receiving requests (request lifecycle, ports, sockets, protocols)
      - Sending responses (status codes, headers, payloads)
      - Sockets and connections (TCP/IP basics, HTTP, WebSockets)
    - Server frameworks (introduced as abstractions solving repetitive boilerplate)
    - Authentication and sessions (solving the problem of state over stateless HTTP)
    - Data access (solving structured persistence and query problems)
    - Cloud
      - Scalability and concurrency (solving performance and resource management)
  - Communication between Frontend and Backend
    - Protocols
- Hosting and deployment
  - Continuous Integration (CI)
  - Continuous Development (CD)
